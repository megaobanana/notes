## 内存溢出/越界访问/内存泄漏

* 数组的越界访问很可能不在刚越界时报错，而是在越界之后再free数组时报错，或者free/malloc其它一个没有任何关系的其它对象时报错

* Address 0x0 is not stack'd, malloc'd...  可能是多个for循环嵌套，然后其中两个for中设的变量为同一个名字（如都叫i）

* 当调试的时候，发现添加/删除一句/一段代码能导致产生/修复一个毫无联系的bug时，不要觉得诡异，这种现象一般在包含有多线程+阻塞IO内容的程序中出现。

  执行代码是需要时间的，如果添加/删去的内容是大量数据操作或print这种需要一些时间的事时，多少会影响到一些异步的操作。

* 如果一个线程卡在了加锁的地方，那么应该检查pthread_mutex_init是否在pthread_create之前